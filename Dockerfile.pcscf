# Multi-stage build for P-CSCF component
FROM golang:1.23-alpine AS builder

WORKDIR /build

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY internal/common ./internal/common
COPY internal/coeur/pcscf ./internal/coeur/pcscf
COPY pkg ./pkg

# Build arguments
ARG COMPONENT=pcscf
ARG VERSION=dev

# Build a simple main that uses P-CSCF
RUN cat > /build/main.go << 'EOF'
package main
import (
    "context"
    "os"
    "os/signal"
    "syscall"
    "time"
    pcscfPkg "github.com/dasmlab/ims/internal/coeur/pcscf"
    gouverneConfig "github.com/dasmlab/ims/internal/gouverne/config"
    "github.com/sirupsen/logrus"
)
func main() {
    log := logrus.New()
    log.SetLevel(logrus.InfoLevel)
    cfg := gouverneConfig.Load()
    pcscfCfg := pcscfPkg.ConfigFromGouverne(cfg)
    pcscf := pcscfPkg.New(pcscfCfg, log)
    ctx := context.Background()
    if err := pcscf.Start(ctx); err != nil {
        log.Fatal(err)
    }
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    pcscf.Stop(shutdownCtx)
}
EOF

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo \
    -ldflags "-X main.version=${VERSION}" \
    -o /build/pcscf \
    /build/main.go

# Runtime stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates curl

WORKDIR /app

# Copy binary from builder
COPY --from=builder /build/pcscf /app/pcscf

# Expose ports
EXPOSE 5060/udp 5060/tcp 5061/tcp 8081/tcp

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8081/health || exit 1

# Run the component
CMD ["/app/pcscf"]
